from typing import Annotated

from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import add_messages
from typing_extensions import TypedDict
from langchain_ollama import ChatOllama
from lib.lattice import Lattice
from lib.tools import create_tools
from langgraph.prebuilt import create_react_agent
from langgraph.checkpoint.memory import InMemorySaver

lattice_session = ""
lattice_client = Lattice()
print(f"Lattice with {lattice_session}")
lattice_client.authenticate("mcp-user", lattice_session)
tools = create_tools(lattice_client)
memory = InMemorySaver()

class State(TypedDict):
    # Messages have the type "list". The `add messages` function
    # in the annotation defines how this state key should be updated
    # (in this case, it appends messages to the list, rather than overwriting them)
    messages: Annotated[list, add_messages]

def stream_graph_updates(user_input: str):
    """
    Thread ID specifies the thread in which the conversation
    is happening and will maintain state of user inputs.
    """
    config = {"configurable": {"thread_id": "1"}}
    events = graph.stream(
        {"messages": [{"role": "user", "content": user_input}]},
        config
    )
    for event in events:
        for value in event.values():
            if 'messages' in value and value['messages']:
                print("Assistant:", value['messages'][-1].content)

# Create the ReAct agent - this handles tool calling automatically
# Here you'll 
llm = ChatOllama(model='qwen-3.0-a3b', temperature=0).bind_tools(tools)
prompt = """
You are an expert reverse engineer that uses Binary Ninja to reverse engineer binaries.
You have access to various tools to help with binary analysis. Use them when needed to answer questions about binaries.
You can access global variables by acquiring the disassembly of a function in the format of data_{address}. Use this if
strings are truncated in the disassembly in pseudocode. Try to use pseudocode when possible as it can give you a better
overview of the functionality. Start your analysis at the _start function, unless you are instructed otherwise.
"""
agent_executor = create_react_agent(llm, tools=tools, prompt=prompt)

# Build the graph - the ReAct agent handles all the routing internally
graph_builder = StateGraph(State)
graph_builder.add_node("agent", agent_executor)
graph_builder.add_edge(START, "agent")
graph_builder.add_edge("agent", END)
graph = graph_builder.compile(checkpointer=memory)

while True:
    user_input = input("User: ")
    if user_input.lower() in ["quit", "exit", "q"]:
        print("Laterz!")
        break
    stream_graph_updates(f"/no_think {user_input}")
